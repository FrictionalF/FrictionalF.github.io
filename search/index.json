[{"content":"A - 123233 题意 给出一个长度为 6 的字符串，判断是否恰好有 1 个 1，2 个 2，3 个 3。\n解法 按照题意模拟即可\nB - Hurdle Parsing 题意 有一个长度为 $N$ ( $N \\ge 1$ ) 的正整数序列 $A = (A_1, A_2, \\dots, A_N)$ 。\n她用 $A$ 生成了如下字符串 $S$ ：\n从 $S =$`| 开始。 对于 $i = 1, 2, \\dots, N$ ，依次执行以下操作： 将 $A_i$ 份 - 追加到 $S$ 的末尾。 然后，在 $S$ 的末尾添加一份 |。 根据生成的字符串 $S$ ，重建序列 $A$ 。\n解法 根据题意模拟即可\nC - D - Strange Mirroring 题意 给你一个由大写和小写英文字母组成的字符串 $S$ 。\n我们对 $S$ 执行以下操作 $10^{100}$ 次：\n首先，将 $S$ 中的大写字母改为小写，小写字母改为大写，从而创建一个字符串 $T$ 。 然后，依次连接 $S$ 和 $T$ 形成新的 $S$ 。 回答 $Q$ 问题。 $i$ -th 查询如下：\n在完成所有运算后，找出 $S$ 开头的第 $K_i$ 个字符。 解法 找出是哪个字符很简单直接取模长度就好了。所以问题的关键就是确定字母的大小写。显然大小写只与这个字符是第几次出现有关。我们先将一些写出来，$1$ 代表原串，$0$ 代表大小写颠倒的原串。那就是 $ 1 0 0 1 0 1 1 0 $，可以发现这是一个很典的规律（据朋友所说），我们将第一次出现的下标设为 $0$，然后我们就可以发现一个字符大小写是否取反取决于它出现次数的下标的 $popcount$ 模 $2$ 的余数。（另外好像不能用 $__builtin_popcount()$，这个好像只能算 $int$ 范围内的数，我就是因为这个赛时怒调40min）\nE - 1D Bucket Tool 题意 有一个长度为 $n$ 的序列，第 $i$ 个元素的颜色为 $i$。有两种操作，操作一是找到第 $x$ 个元素，将与他相邻的且颜色相同的元素的颜色都改成 $c$。操作二是查询颜色为 $c$ 的元素个数。\n解法 这种合并的操作一看就很像并查集，但是我们要考虑怎么去维护。\n首先看操作一，因为合并是区间合并，我们在更改完颜色后要判断是不是可以和左右区间合并，这我们就要维护区间左端点和右端点，每次将更改的颜色与左端点的前一个和右端点的后一个比较以下，同时显然肯定要记录一下这个并查集的颜色。\n再来看操作二，这就很简单了，我们维护完操作一，只需要维护并查集大小和每种颜色个数，每次修改时加上或减去就可以了。\nCode A - 123233\nB - Hurdle Parsing\nC - Move Segment\nD - Strange Mirroring\nE - 1D Bucket Tool\n","date":"2024-11-18T13:36:16+08:00","image":"http://localhost:1313/p/abc380%E9%A2%98%E8%A7%A3/01_hu8964326403510737175.jpg","permalink":"http://localhost:1313/p/abc380%E9%A2%98%E8%A7%A3/","title":"ABC380题解"},{"content":"一开始想从前向后做，发现好像贪心没有正确性（或许是我太菜了，没想到更好的贪心方法）。\n遂考虑从后向前做，我们发现如果 $S$ 从后向前有一个后缀向前扩一个后仍然是 $T$ 的前缀，那么就向前扩是更优的，且不会影响无解的情况。因为如果本来不扩是有解的，那扩完后，前面一个 $T$ 的前缀仍然是 $T$ 的前缀。这样我们就要求出来对于 $S$ 的每一个前缀的最长与 $T$ 的前缀相同的后缀。那这不就成了 KMP 的板子了。求出这个后就每次减掉一个满足条件的 $S$ 的最长后缀，至于无解不就是对于当前的 $S$，不存在一个后缀等于 $T$ 的某个前缀。\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include\u0026lt;bits/stdc++.h\u0026gt; #define fi first #define se second #define db double #define U unsigned #define int long long #define P pair\u0026lt;int,int\u0026gt; #define pb push_back #define MP make_pair #define all(x) x.begin(),x.end() #define CLR(i,a) memset(i,a,sizeof(i)) #define FOR(i,a,b) for(int i=a;i\u0026lt;=b;++i) #define ROF(i,a,b) for(int i=a;i\u0026gt;=b;--i) #define debug(x) cerr\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#39;=\u0026#39;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;endl #define MIN(a,b) ((a)\u0026lt;(b)?(a):(b)) #define MAX(a,b) ((a)\u0026gt;(b)?(a):(b)) #define pcn putchar(\u0026#39;\\n\u0026#39;) #define pcs putchar(\u0026#39; \u0026#39;); #define pc putchar #define File(x) freopen(x\u0026#34;.in\u0026#34;,\u0026#34;r\u0026#34;,stdin);freopen(x\u0026#34;.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); #define ClockB clock_t start,end; start = clock(); #define ClockE end = clock(); cerr\u0026lt;\u0026lt;\u0026#34;time = \u0026#34;\u0026lt;\u0026lt;double(end-start)/CLOCKS_PER_SEC\u0026lt;\u0026lt;\u0026#34;s\u0026#34;\u0026lt;\u0026lt;endl; using namespace std; int _=1; inline int rd(){ int x=0,f=1; char ch=getchar(); while(ch\u0026lt;\u0026#39;0\u0026#39;||ch\u0026gt;\u0026#39;9\u0026#39;){if(ch==\u0026#39;-\u0026#39;) f=-1;ch=getchar();} while(ch\u0026gt;=\u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch\u0026lt;=\u0026#39;9\u0026#39;) x=(x\u0026lt;\u0026lt;1)+(x\u0026lt;\u0026lt;3)+(ch^48),ch=getchar(); return x*f; } inline void wr(int x){ if(x\u0026lt;0) pc(\u0026#39;-\u0026#39;),x=(~x)+1; if(x\u0026gt;9) wr(x/10); pc((x%10)^48); } int lens,lent; const int N=1e7+3; char t[N],s[N]; int nex[N*2]; int cnt; char tmp[N*2]; int ans[N*2]; signed main(){ // _=rd(); while(_--){ lent=rd(),lens=rd(); scanf(\u0026#34;%s\u0026#34;,t+1);scanf(\u0026#34;%s\u0026#34;,s+1); FOR(i,1,lent) tmp[i]=t[i]; FOR(i,lent+1,lent+lens) tmp[i]=s[i-lent]; int j=0; nex[1]=0; FOR(i,2,lent){ while(j\u0026amp;\u0026amp;t[i]!=t[j+1]) j=nex[j]; if(t[i]==t[j+1]) j++; nex[i]=j; } j=0; FOR(i,1,lens){ while(j\u0026amp;\u0026amp;s[i]!=t[j+1]) j=nex[j]; if(s[i]==t[j+1]) j++; ans[i]=j; } while(lens\u0026gt;0){ if(!ans[lens]){ cout\u0026lt;\u0026lt;\u0026#34;Fake\u0026#34;; return 0; } lens-=ans[lens]; cnt++; } cout\u0026lt;\u0026lt;cnt; } return 0; } ","date":"2024-11-17T22:03:05+08:00","image":"http://localhost:1313/p/p8112cnoi2021%E7%AC%A6%E6%96%87%E7%A0%B4%E8%AF%91%E9%A2%98%E8%A7%A3/05_hu2073597190819076578.jpg","permalink":"http://localhost:1313/p/p8112cnoi2021%E7%AC%A6%E6%96%87%E7%A0%B4%E8%AF%91%E9%A2%98%E8%A7%A3/","title":"P8112[Cnoi2021]符文破译题解"},{"content":"题意 给定一个无向图，其中有一些只有一个端点的虚边，对于每个 $i=1,2,3,\u0026hellip;,n$ 将这些虚边连向 $i$ ,对于每个 $i$ 求出 $1$ 到 $n$ 的最短路，无法到达输出 $-1$。\n解法 发现连边后的图与连边前的图只有那几个虚边发生了变化，（先将那个所有虚边连向的点 $i$ 叫做中心点），也就是说变化的只有各个点到 $i$ 的最短距离（也可能没变），可以用到各个虚点距离来更新到中心点的最短距离，而我们只关注 $1$ 和 $n$ 到中心点的距离。这样的话 $1$ 到 $n$ 的最短距离就是（原本的最短距离）与（$1$ 到中心点的最短距离与 $n$ 到中心点的距离的和）的最小值。\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 #include\u0026lt;bits/stdc++.h\u0026gt; #define fi first #define se second #define db double #define U unsigned #define int long long #define P pair\u0026lt;int,int\u0026gt; #define pb push_back #define MP make_pair #define all(x) x.begin(),x.end() #define CLR(i,a) memset(i,a,sizeof(i)) #define FOR(i,a,b) for(int i=a;i\u0026lt;=b;++i) #define ROF(i,a,b) for(int i=a;i\u0026gt;=b;--i) #define debug(x) cerr\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#39;=\u0026#39;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;endl #define MIN(a,b) ((a)\u0026lt;(b)?(a):(b)) #define MAX(a,b) ((a)\u0026gt;(b)?(a):(b)) #define pcn putchar(\u0026#39;\\n\u0026#39;) #define pcs putchar(\u0026#39; \u0026#39;); #define pc putchar #define File(x) freopen(x\u0026#34;.in\u0026#34;,\u0026#34;r\u0026#34;,stdin);freopen(x\u0026#34;.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); #define ClockB clock_t start,end; start = clock(); #define ClockE end = clock(); cerr\u0026lt;\u0026lt;\u0026#34;time = \u0026#34;\u0026lt;\u0026lt;double(end-start)/CLOCKS_PER_SEC\u0026lt;\u0026lt;\u0026#34;s\u0026#34;\u0026lt;\u0026lt;endl; using namespace std; int _=1; inline int rd(){ int x=0,f=1; char ch=getchar(); while(ch\u0026lt;\u0026#39;0\u0026#39;||ch\u0026gt;\u0026#39;9\u0026#39;){if(ch==\u0026#39;-\u0026#39;) f=-1;ch=getchar();} while(ch\u0026gt;=\u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch\u0026lt;=\u0026#39;9\u0026#39;) x=(x\u0026lt;\u0026lt;1)+(x\u0026lt;\u0026lt;3)+(ch^48),ch=getchar(); return x*f; } inline void wr(int x){ if(x\u0026lt;0) pc(\u0026#39;-\u0026#39;),x=(~x)+1; if(x\u0026gt;9) wr(x/10); pc((x%10)^48); } int n,m; const int N=32e5+5; //以下的所有2是和点1有关的，1是和点n有关的 int dis1[N],dis2[N]; int u,v; vector\u0026lt;int\u0026gt;im; vector\u0026lt;int\u0026gt;ng[N]; bitset\u0026lt;N\u0026gt;vis; void bfs(int s){ FOR(i,1,n) dis1[i]=1e18; queue\u0026lt;int\u0026gt;q; q.push(s); dis1[s]=0; while(!q.empty()){ int u=q.front(); q.pop(); vis[u]=1; for(auto x:ng[u]){ dis1[x]=MIN(dis1[x],dis1[u]+1); if(!vis[x]) q.push(x); } } } int minn2=1e18,minn1=1e18; int tmp2,tmp1; int dis; signed main(){ // _=rd(); while(_--){ n=rd(),m=rd(); FOR(i,1,m){ u=rd(),v=rd(); if(u) ng[u].pb(v),ng[v].pb(u); else im.pb(v); } bfs(1); FOR(i,1,n) dis2[i]=dis1[i]; vis=0; bfs(n);//分别求出1和n到所有点的最短距离 for(auto i:im) minn2=MIN(minn2,dis2[i]),minn1=MIN(minn1,dis1[i]);//处理1和n到所有虚边端点的最短距离，便于更新中心点的最短距离 FOR(i,1,n){ tmp1=dis1[i],tmp2=dis2[i]; dis1[i]=MIN(dis1[i],minn1+1),dis2[i]=MIN(dis2[i],minn2+1); dis=MIN(dis2[n],dis1[i]+dis2[i]); cout\u0026lt;\u0026lt;((dis==1e18)?-1:dis)\u0026lt;\u0026lt;\u0026#39; \u0026#39;; dis1[i]=tmp1,dis2[i]=tmp2; } } return 0; } ","date":"2024-11-17T21:30:27+08:00","image":"http://localhost:1313/p/abc257_f%E9%A2%98%E8%A7%A3/bj_hu6307248181568134095.jpg","permalink":"http://localhost:1313/p/abc257_f%E9%A2%98%E8%A7%A3/","title":"ABC257_F题解"},{"content":"前言 集训的时候讲了子集反演，于是想了解一下其他的反演，便去学了莫反。于是想写一篇讲解，顺便来巩固一下，加深一下理解。\n前置知识 艾弗森括号 $\\left[P\\right]=\\begin{cases}1\\ \\ \\ P\\ is\\ true \\ 0\\ \\ \\ Otherwise\\end{cases}$ 相当于强转 $bool$ 类型的一个括号。\n数论分块 快速求解的工具，这里不展开讲解了，详解见数论分块 by: mango09\n积性函数 定义 满足 $f(xy)=f(x)f(y)$ 的函数称为积性函数。\n常见的几种积性函数 $I(n)=1$ $e(n)=\\left[n=1\\right]$ $\\mathrm{Id}_k(n)=n^k，通常 \\mathrm{Id}_1(n)记为\\mathrm{Id}(n)$ $d(n)=\\sum\\limits_{d|n}1$ 即 $n$ 的因数个数 $\\sigma_k(n)=\\sum\\limits_{d|n}{d^k}$ $\\quad \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad$ 特别的，$k=0$ 时，为因子个数，即 $d(n)$ $\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad$ $\\quad \\quad \\ \\ $，$ k=1$ 时，为因子和，通常记为 $\\sigma(n)$ 欧拉函数 $\\varphi(n)=\\sum\\limits_{i=1}^n\\left[\\gcd(i,n)=1\\right]$ 莫比乌斯函数 下面有定义 莫比乌斯函数 $\\ $\n定义 $\\ $\n上面已经提到了莫比乌斯函数 $\\mu$ 的定义，这里再解释一下。第一种情况对应的就是 $\\mu(1)=1$，第二种情况的意思是 $n\\ =\\ \\prod\\limits_{p_i|n}{{p_i}^{c_i}}$。其中，$p_i$ 均为质数。显然对于所有 $n$，都能写成这样的形式（即分解质因数）。若 $\\exists\\ c_i\u0026gt;1$ 则 $\\mu(n)=0$。否则 $\\mu(n)\\ =\\ (-1)^k$，其中 $k$ 为 $n$ 的质因子个数。\n性质 $$ \\sum\\limits_{d|n}\\mu(d)=\\left[n=1\\right]$$ $\\qquad$ 让我们来简单证明一下，首先对于 $n=1$ 时，那么显然这个式子成立。再来考虑 $n\u0026gt;1$ 时，我们令 $n\\ =\\ \\prod\\limits_{p_i|n}{{p_i}^{c_i}}$。其中，$p_i$ 均为质数。那么 $n$ 的因子相当于在这些 $p$ 中任选几个相乘。显然当某个 $p_i$ 选了多次时，那么 $\\mu(d)=0$，我们不做考虑。这样我们就能把左边的和式变成 $\\sum\\limits_{i=0}^k{C_k^i}\\times(-1)^{i}=\\sum\\limits_{i=0}^k{C_k^i}\\times(-1)^i\\times1^{k-i}$，由二项式定理得，这个式子就是 $(-1+1)^k=0$，得证！\n求莫比乌斯函数 $\\ $\n因为莫比乌斯函数是积性函数，所以我们可以用线性筛来求。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int primes[N],mu[N],k; bitset\u0026lt;N\u0026gt;st; void Prime(int x){ mu[1]=1; for(int i=2;i\u0026lt;=x;++i){ if(!st[i]){ primes[++k]=i; mu[i]=-1; } for(int j=1;primes[j]*i\u0026lt;=x;++j){ st[i*primes[j]]=1; if(!(i%primes[j])) break; mu[i*primes[j]]=-mu[i]; } } } 狄利克雷 $(Dirichlet)$ 卷积 定义 定义两个数论函数（$f,g$）的狄利克雷卷积为： $$\\\\ (f*g)(n)=\\sum\\limits_{d|n}f(d)g(\\frac{n}{d})$$ 性质 满足交换律($fg=gf$)，结合律$(fgh=f*(gh))$，分配律$(f(g+h)=fg+fh)$ 任何数论函数卷上单位函数 $e$ 都为它本身，即 $(f*e)(n)=f(n)$ 两个积性函数 $f,g$ 卷积后，仍为积性函数，即 $f*g$ 为积性函数。 常见积性函数与狄利克雷卷积的性质 1. 关于单位函数 $$e=\\mu *I=\\sum\\limits_{d|n}\\mu(d)$$ $\\quad$ 证明：\n$\\qquad\\qquad$ 我们前面已经证过 $\\sum\\limits_{d|n}\\mu(d)=\\left[n=1\\right]$，而单位函数 $e=\\left[n=1\\right]$。得证！\n通过这个性质，我们也能知道，$\\mu$ 其实就是 $I$ 的逆。\n2. 关于欧拉函数 $$\\varphi * I=\\mathrm{Id}$$$$\\\\ \\varphi=\\mathrm{Id}*\\mu$$ 证明：\n$\\qquad\\qquad$ 第一个性质展开之后就是 $\\sum\\limits_{d|n}\\varphi(d)=n$。我们设 $f(x)=\\sum\\limits_{i=1}^n{\\left[\\gcd(i,n)=x\\right]}$ 那么显然，$n=\\sum\\limits_{i=1}^nf(i)$，而 $f(x)=\\varphi(\\frac{n}{x})$，所以 $n=\\sum\\limits_{d|n}\\varphi(\\frac{n}{d})$ 同时 $n$ 的因子又满足对称性，所以就能得到 $n=\\sum\\limits_{d|n}\\varphi(d)$。\n$\\qquad\\qquad$ 对于第二个性质，我们在第一个式子的基础上，两边同时卷上 $\\mu$，则左边为 $\\varphi* I * \\mu=\\varphi * e=\\varphi$，右边为 $\\mathrm{Id}*\\mu$，得证！\n3. 关于幂函数 和除数函数\n$$\\mathrm{Id}_k*I=\\sigma_k$$证明：\n左边展开后为 $\\sum\\limits_{d|n}{d^k}$，等于右边，得证！\n三、莫比乌斯反演 结论1 若有两个数论函数 $f,g$，且满足 $$f=g*I$$ 则有 $$g=f*\\mu$$ 证明：证明很好证，就是将第一个式子带入到第二个式子中看是否成立，即 $g=gI\\mu=g*(\\muI)=ge=g$，得证！另外提一嘴，这两个命题是充要的，证明与其类似。\n结论2 $$\\left[\\gcd(i,j)=1\\right]=\\sum\\limits_{d|\\gcd(i,j)}\\mu(d)$$ 感觉好像是废话，其实就是上面的莫比乌斯函数的性质将 $\\gcd(i,j)$ 带入到那里的 $n$ 而已，不再证明。\n四、套路和一些例题 感觉莫反的题大部分和最大公约数求和有关\n套路 求：\n$$\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^mf(\\gcd(i,j))$$设 $f=g*I=\\sum\\limits_{d|n}g(d)$ 则原式化为 $$\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m\\sum\\limits_{d|\\gcd(i,j)}g(d)$$ 变化一下求和顺序，先枚举 $d$，因为 $d|\\gcd(i,j)$，所以$d|i$ 且 $d|j$，则原式变为 $$\\sum\\limits_{d=1}^{min(n,m)} \\left\\lfloor\\dfrac{n}{d}\\right\\rfloor \\left\\lfloor\\dfrac{m}{d}\\right\\rfloor g(d)$$ $\\dag$：这一步式子好像解释的不是很清晰，我再解释一下。首先先来看原来的式子，若有一个 $d$ 使得 $d|i$ 且 $d|j$，那么 $d$ 在 $n$ 中会计算 $\\left\\lfloor\\dfrac{n}{d}\\right\\rfloor$ 次（即 $d$ 的倍数次），在 $m$ 中同理，会计算 $\\left\\lfloor\\dfrac{m}{d}\\right\\rfloor$ 次。用乘法原理对于每一个 $d$ 都会计算 $\\left\\lfloor\\dfrac{m}{d}\\right\\rfloor\\times\\left\\lfloor\\dfrac{n}{d}\\right\\rfloor$ 次，再乘上 $g(d)$，就能得出来这个式子了。\n若我们知道了 $g$ 的所有取值，那么我们就可以用数论分块求解了。所以，现在我们的主要问题变成了求解 $g$。这就可以用莫比乌斯反演了，由莫比乌斯反演得 $g=\\mu *f$。$g$ 是一个积性函数,所以也可以用线性筛求解。\n例题1 求： $$\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m \\gcd(i,j)$$ 要求这个，就是求 $$\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m\\mathrm{Id}(\\gcd(i,j))$$ 那上面的 $g=Id*\\mu=\\varphi$,所以答案就是 $$\\sum\\limits_{d=1}^{min(n,m)} \\left\\lfloor\\dfrac{n}{d}\\right\\rfloor \\left\\lfloor\\dfrac{m}{d}\\right\\rfloor \\varphi(d)$$ 实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 int primes[N]; bitset\u0026lt;N\u0026gt;st; int k; int phi[N]，sum[N]; void Prime(int x){//处理欧拉函数和前缀和 phi[1]=1; for(int i=2;i\u0026lt;=x;++i){ if(!st[i]){ primes[++k]=i; phi[i]=i-1; } for(int j=1;primes[j]*i\u0026lt;=x;++j){ st[i*primes[j]]=1; if(i%primes[j]==0){ phi[i*primes[j]]=phi[i]*primes[j]; break; } phi[i*primes[j]]=phi[i]*phi[primes[j]]; } } for(int i=1;i\u0026lt;=x;++i) sum[i]=sum[i-1]+phi[i]; } int solve(int n,int m){//数论分块求解 if(n\u0026gt;m) swap(n,m); int l=1,r=1,ans=0; while(l\u0026lt;=n){ r=MIN(n/(n/l),m/(m/l)); ans+=(n/l)*(m/l)*(sum[r]-sum[l-1]); l=r+1; } return ans; } 例题2 求： $$\\sum\\limits_{i=1}^n \\sum\\limits_{j=1}^m \\left[\\gcd(i,j)=1\\right]$$ 这就可以用到我们上面提到的莫比乌斯反演结论2了，则原式化为 $$\\sum\\limits_{i=1}^n \\sum\\limits_{j=1}^m\\sum\\limits_{d|\\gcd(i,j)}\\mu(d)$$ 还是和上面一样的变换一下求和顺序，得到 $$\\sum\\limits_{d=1}^{min(n,m)}\\left\\lfloor \\frac{n}{d}\\right\\rfloor\\left\\lfloor \\frac{m}{d}\\right\\rfloor\\mu(d)$$ 与例题1类似的求法，不再放code。\n特别鸣谢 $\\ \\quad$@qiliu $\\ \\quad$\n","date":"2024-11-17T20:13:04+08:00","image":"http://localhost:1313/p/%E8%8E%AB%E5%8F%8D%E6%B5%85%E8%B0%88/bj_hu17783870395121941736.jpg","permalink":"http://localhost:1313/p/%E8%8E%AB%E5%8F%8D%E6%B5%85%E8%B0%88/","title":"莫反浅谈"},{"content":"终于弄好 Blog 了，虽然自己什么代码也没写，但是也是捣鼓了一整天。以后会发一些好东西的！\n","date":"2024-11-17T20:08:03+08:00","permalink":"http://localhost:1313/p/hello/","title":"Hello"}]